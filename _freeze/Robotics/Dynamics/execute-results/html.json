{
  "hash": "6d85a4f802495ffae1c862a60c40bf7e",
  "result": {
    "markdown": "---\ntitle: \"Robot Dynamics\"\ndescription: \"Robot Dynamics encompasses the analysis of forces like Coriolis effects, mass distribution, and gravity on a robot, crucial for designing control strategies. This understanding ensures precise and stable movements in various operational scenarios\"\ndate: 12-12-2023\ncategories: [Robotics]\nimage: Dynamics_Pendulum_Cover_GIF.gif\nformat:\n    html: \n        code-fold: show\n        code-overflow: wrap\n        code-tools: true\n---\n\n## Robot Dynamics\n\n![](Images/Pendulum_Simulation_Problem.png){fig-align=\"center\" width=50%}\n\nHere we will simulate the dynamics of the planar robot shown above. We have the dynamics of this robot mentioned in the code.\n\nNow we combine our simulation with the dynamics we have for the specified robot. We will need to get the (ùë•, ùë¶) position of each link to plot the robot. We are using the given simulation parameters and frame rates.\n\n* Make a simulation where $\\normalsize \\tau = [0, 0]^{ùëá}$ and the robot has no friction.\n    \n* Make a simulation where $\\normalsize \\tau = [0, 0]^{ùëá}$ and the robot has viscous friction ùêµ = ùêº.\n    \n* Make a simulation where $\\normalsize \\tau = [20, 5]^{ùëá}$ and the robot has viscous friction ùêµ = ùêº.\n\nWe can play with the parameters (such as mass, inertia, friction, and ùúè), and see how these parameters affect the simulation.\nWe can see the implementations below for the simulation codes I am responsible for.\n\n* **Environment 1:** Make a simulation where $\\normalsize \\tau = [0, 0]^{ùëá}$ and the robot has no friction.\n\n### Implementations\n\n#### Python\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom matplotlib.animation import PillowWriter\nfrom scipy.spatial.transform import Rotation as R\n\ndef expm(A):\n    return np.linalg.matrix_power(np.eye(A.shape[0]) + A / 16, 16)\n\ndef bracket_s(s):\n    return np.array([[0, -s[2], s[1], s[3]], [s[2], 0, -s[0], s[4]], [-s[1], s[0], 0, s[5]], [0, 0, 0, 0]])\n\ndef fk(M, S, theta):\n    T = np.eye(4)\n    for i in range(len(theta)):\n        T = np.dot(T, expm(bracket_s(S[:, i]) * theta[i]))\n    return np.dot(T, M)\n\n# System parameters\nL1 = 1\nL2 = 1\nm1 = 1\nm2 = 1\nI1 = 0.1\nI2 = 0.1\ng = 9.81\ntau = np.array([0, 0])  # Case 1\n\n# Initial conditions\ntheta = np.array([0.0, 0.0])\nthetadot = np.array([0.0, 0.0])\nthetadotdot = np.array([0.0, 0.0])\n\nomega = np.array([0, 0, 1])\nq1 = np.array([0, 0, 0])\nq2 = np.array([L1, 0, 0])\nq3 = np.array([L1 + L2, 0, 0])\n\nS1 = np.hstack((omega, -np.cross(omega, q1)))\nS2 = np.hstack((omega, -np.cross(omega, q2)))\nS_eq1 = np.column_stack((S1, np.zeros(6)))\nS_eq2 = np.column_stack((S1, S2))\n\nM1 = np.vstack((np.hstack((np.eye(3), q2[:, None])), [0, 0, 0, 1]))\nM2 = np.vstack((np.hstack((np.eye(3), np.array([[L1 + L2, 0, 0]]).T)), [0, 0, 0, 1]))\n\n# Plot setup\nmax_reach = L1 + L2\nfig, ax = plt.subplots()\nax.set_xlim(-3, 3)\nax.set_ylim(-3, 3)\nax.grid()\n\n# Animation setup\nframes = 1000\ndeltaT = 0.01\nlines, = ax.plot([], [], 'o-', color=[1, 0.5, 0], linewidth=4)\n\n\ndef animate(idx):\n    global theta, thetadot, thetadotdot\n    p0 = np.array([0,0])\n    T1 = fk(M1, S_eq2[:, 0:1], theta[0:1])\n    p1 = T1[0:2, 3]\n    T2 = fk(M2, S_eq2, theta)\n    p2 = T2[0:2, 3]\n    P = np.column_stack((p0, p1, p2))\n\n    lines.set_data(P[0, :], P[1, :])\n\n    thetadot += deltaT * thetadotdot\n    theta += deltaT * thetadot\n\n    # Dynamics and integration\n    Mass_Matrix = np.array([\n        [I1 + I2 + L1**2*m1 + L1**2*m2 + L2**2*m2 + 2*L1*L2*m2*np.cos(theta[1]), m2*L2**2 + L1*m2*np.cos(theta[1])*L2 + I2],\n        [m2*L2**2 + L1*m2*np.cos(theta[1])*L2 + I2, m2*L2**2 + I2]\n    ])\n\n    Coriolis_Matrix = np.array([\n        [-L1*L2*m2*thetadot[1]*np.sin(theta[1]), -L1*L2*m2*np.sin(theta[1])*(thetadot[0] + thetadot[1])],\n        [L1*L2*m2*thetadot[0]*np.sin(theta[1]), 0]\n    ])\n\n    gravity_vector = np.array([\n        g*(m1 + m2)*L1*np.cos(theta[0]) + g*m2*L2*np.cos(np.sum(theta)),\n        g*m2*L2*np.cos(np.sum(theta))\n    ])\n\n    B = np.array([[0, 0], [0, 0]])  # Case 1\n\n    thetadotdot = np.linalg.inv(Mass_Matrix) @ (tau - Coriolis_Matrix @ thetadot - B @ thetadot - gravity_vector)\n \n\n    return lines,\n\nani = animation.FuncAnimation(fig, animate, frames=frames, interval=deltaT*1000, blit=False)\n\n# Save as GIF\nani.save('Pendulum_Python_1.gif', writer=PillowWriter(fps=33))\n```\n:::\n\n\n#### MATLAB\n\n<details>\n<summary>Code</summary>\n\n```matlab\n\nclose all\nclear\nclc\n\n\n% create figure\nfigure\naxis([-2, 2, -2, 2])\ngrid on\nhold on\n\n% save as a video file\nv = VideoWriter('Pendulum_Case_1.mp4', 'MPEG-4');\nv.FrameRate = 100;\nopen(v);\n\n% pick your system parameters\nL1 = 1;\nL2 = 1;\nm1 = 1;\nm2 = 1;\nI1 = 0.1;\nI2 = 0.1;\ng = 9.81;\ntau = [0;0]; % Case 1\n\n% Initial conditions\ntheta = [0;0]; % joint position\nthetadot = [0;0]; % joint velocity\nthetadotdot = [0;0]; % joint acceleration\n\nmasses = [m1,m2];\nomega = [0;0;1];\n\nInertia_1 = [0 0 0;0 0 0;0 0 I1];\nInertia_2 = [0 0 0;0 0 0;0 0 I2];\nq1 = [0;0;0]; % Position of Joint 1\nq2 = [L1;0;0]; % Position of Joint 2\nq3 = [L1+L2;0;0]; % end effector position\n\nS1 = [omega; -cross(omega,q1)];\nS2 = [omega;-cross(omega,q2)];\nS_eq1 = [S1,[0;0;0;0;0;0]];\nS_eq2 = [S1, S2]; \n\nM1 = [eye(3),q2; 0 0 0 1];\nM2 = [eye(3), [L1+L2;0;0]; 0 0 0 1];\n\ngravity_vector = (zeros(length(theta),1));\nCoriolis_Matrix = (zeros(2,2));\nMass_Matrix = [I1 + I2 + L1^2*m1 + L1^2*m2 + L2^2*m2 + 2*L1*L2*m2*cos(theta(2)), m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2; m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2, m2*L2^2 + I2];\n    \n\nfor idx = 1:1000\n\n    % plot the robot\n    % 1. get the position of each link\n    p0 = [0; 0];\n    T1 = fk(M1,S_eq2(:,1:1),theta(1:1,:));\n    p1 = T1(1:2,4); % position of link 1 (location of joint 2)\n    T2 = fk(M2,S_eq2,theta);\n    p2 = T2(1:2,4); % position of link 2 (the end-effector)\n    P = [p0, p1, p2];\n    % 2. draw the robot and save the frame\n    cla;\n    plot(P(1,:), P(2,:), 'o-', 'color',[1, 0.5, 0],'linewidth',4);\n    drawnow;\n    frame = getframe(gcf);\n    writeVideo(v,frame);\n\n    % integrate to update velocity and position\n    % your code here\n    deltaT = 0.01;\n    thetadot = thetadot + deltaT * thetadotdot;\n    theta = theta + deltaT * thetadot;\n\n    Mass_Matrix =[I1 + I2 + L1^2*m1 + L1^2*m2 + L2^2*m2 + 2*L1*L2*m2*cos(theta(2)), m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2; m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2, m2*L2^2 + I2];\n    \n    Coriolis_Matrix = [-L1*L2*m2*thetadot(2)*sin(theta(2)),  -L1*L2*m2*sin(theta(2))*(thetadot(1) + thetadot(2));L1*L2*m2*thetadot(1)*sin(theta(2)), 0] ;\n    \n    gravity_vector = [(g*(m1+m2)*L1*cos(theta(1))) + g*m2*L2*cos(theta(1) + theta(2)); g*m2*L2*cos(theta(1) + theta(2))];\n    \n    B = [[0 0]\n        [0 0]]; % Case 1\n\n    thetadotdot = (inv(Mass_Matrix)) * (tau - Coriolis_Matrix * thetadot -B*thetadot - gravity_vector);\n\nend\n\nclose(v);\nclose all\n```\n</details>\n\n#### Result:\n\n<img src=\"Pendulum_Case_1.gif\" alt=\"Animated GIF\" loop width=\"50%\" height=\"100%\">\n\n\n* **Environment 2:** Make a simulation where $\\normalsize \\tau = [0, 0]^ùëá$ and the robot has viscous friction $\\normalsize ùêµ = ùêº$.\n\n### Implementations\n\n#### Python\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom matplotlib.animation import PillowWriter\nfrom scipy.spatial.transform import Rotation as R\n\ndef expm(A):\n    return np.linalg.matrix_power(np.eye(A.shape[0]) + A / 16, 16)\n\ndef bracket_s(s):\n    return np.array([[0, -s[2], s[1], s[3]], [s[2], 0, -s[0], s[4]], [-s[1], s[0], 0, s[5]], [0, 0, 0, 0]])\n\ndef fk(M, S, theta):\n    T = np.eye(4)\n    for i in range(len(theta)):\n        T = np.dot(T, expm(bracket_s(S[:, i]) * theta[i]))\n    return np.dot(T, M)\n\n# System parameters\nL1 = 1\nL2 = 1\nm1 = 1\nm2 = 1\nI1 = 0.1\nI2 = 0.1\ng = 9.81\ntau = np.array([0, 0])  # Case 2\n\n# Initial conditions\ntheta = np.array([0.0, 0.0])\nthetadot = np.array([0.0, 0.0])\nthetadotdot = np.array([0.0, 0.0])\n\nomega = np.array([0, 0, 1])\nq1 = np.array([0, 0, 0])\nq2 = np.array([L1, 0, 0])\nq3 = np.array([L1 + L2, 0, 0])\n\nS1 = np.hstack((omega, -np.cross(omega, q1)))\nS2 = np.hstack((omega, -np.cross(omega, q2)))\nS_eq1 = np.column_stack((S1, np.zeros(6)))\nS_eq2 = np.column_stack((S1, S2))\n\nM1 = np.vstack((np.hstack((np.eye(3), q2[:, None])), [0, 0, 0, 1]))\nM2 = np.vstack((np.hstack((np.eye(3), np.array([[L1 + L2, 0, 0]]).T)), [0, 0, 0, 1]))\n\n# Plot setup\nmax_reach = L1 + L2\nfig, ax = plt.subplots()\nax.set_xlim(-3, 3)\nax.set_ylim(-3, 3)\nax.grid()\n\n# Animation setup\nframes = 1000\ndeltaT = 0.01\nlines, = ax.plot([], [], 'o-', color=[1, 0.5, 0], linewidth=4)\n\n\ndef animate(idx):\n    global theta, thetadot, thetadotdot\n    p0 = np.array([0,0])\n    T1 = fk(M1, S_eq2[:, 0:1], theta[0:1])\n    p1 = T1[0:2, 3]\n    T2 = fk(M2, S_eq2, theta)\n    p2 = T2[0:2, 3]\n    P = np.column_stack((p0, p1, p2))\n\n    lines.set_data(P[0, :], P[1, :])\n\n    thetadot += deltaT * thetadotdot\n    theta += deltaT * thetadot\n\n    # Dynamics and integration\n    Mass_Matrix = np.array([\n        [I1 + I2 + L1**2*m1 + L1**2*m2 + L2**2*m2 + 2*L1*L2*m2*np.cos(theta[1]), m2*L2**2 + L1*m2*np.cos(theta[1])*L2 + I2],\n        [m2*L2**2 + L1*m2*np.cos(theta[1])*L2 + I2, m2*L2**2 + I2]\n    ])\n\n    Coriolis_Matrix = np.array([\n        [-L1*L2*m2*thetadot[1]*np.sin(theta[1]), -L1*L2*m2*np.sin(theta[1])*(thetadot[0] + thetadot[1])],\n        [L1*L2*m2*thetadot[0]*np.sin(theta[1]), 0]\n    ])\n\n    gravity_vector = np.array([\n        g*(m1 + m2)*L1*np.cos(theta[0]) + g*m2*L2*np.cos(np.sum(theta)),\n        g*m2*L2*np.cos(np.sum(theta))\n    ])\n\n    B = np.array([[1, 0], [0, 1]])  # Case 2\n\n    thetadotdot = np.linalg.inv(Mass_Matrix) @ (tau - Coriolis_Matrix @ thetadot - B @ thetadot - gravity_vector)\n \n\n    return lines,\n\nani = animation.FuncAnimation(fig, animate, frames=frames, interval=deltaT*1000, blit=False)\n\n# Save as GIF\nani.save('Pendulum_Python_2.gif', writer=PillowWriter(fps=33))\n```\n:::\n\n\n#### MATLAB\n\n<details>\n<summary>Code</summary>\n\n```matlab\n\nclose all\nclear\nclc\n\n% create figure\nfigure\naxis([-2, 2, -2, 2])\ngrid on\nhold on\n\n% save as a video file\nv = VideoWriter('Pendulum_Case_2.mp4', 'MPEG-4');\nv.FrameRate = 100;\nopen(v);\n\n% pick your system parameters\nL1 = 1;\nL2 = 1;\nm1 = 1;\nm2 = 1;\nI1 = 0.1;\nI2 = 0.1;\ng = 9.81;\ntau = [0;0]; % Case 2\n\n% Initial conditions\ntheta = [0;0]; % joint position\nthetadot = [0;0]; % joint velocity\nthetadotdot = [0;0]; % joint acceleration\n\nmasses = [m1,m2];\nomega = [0;0;1];\n\nInertia_1 = [0 0 0;0 0 0;0 0 I1];\nInertia_2 = [0 0 0;0 0 0;0 0 I2];\nq1 = [0;0;0]; % Position of Joint 1\nq2 = [L1;0;0]; % Position of Joint 2\nq3 = [L1+L2;0;0]; % end effector position\n\nS1 = [omega; -cross(omega,q1)];\nS2 = [omega;-cross(omega,q2)];\nS_eq1 = [S1,[0;0;0;0;0;0]];\nS_eq2 = [S1, S2]; \n\nM1 = [eye(3),q2; 0 0 0 1];\nM2 = [eye(3), [L1+L2;0;0]; 0 0 0 1];\n\ngravity_vector = (zeros(length(theta),1));\nCoriolis_Matrix = (zeros(2,2));\nMass_Matrix = [I1 + I2 + L1^2*m1 + L1^2*m2 + L2^2*m2 + 2*L1*L2*m2*cos(theta(2)), m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2; m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2, m2*L2^2 + I2];\n    \n\nfor idx = 1:1000\n\n    % plot the robot\n    % 1. get the position of each link\n    p0 = [0; 0];\n    T1 = fk(M1,S_eq2(:,1:1),theta(1:1,:));\n    p1 = T1(1:2,4); % position of link 1 (location of joint 2)\n    T2 = fk(M2,S_eq2,theta);\n    p2 = T2(1:2,4); % position of link 2 (the end-effector)\n    P = [p0, p1, p2];\n    % 2. draw the robot and save the frame\n    cla;\n    plot(P(1,:), P(2,:), 'o-', 'color',[1, 0.5, 0],'linewidth',4);\n    drawnow;\n    frame = getframe(gcf);\n    writeVideo(v,frame);\n\n    % integrate to update velocity and position\n    % your code here\n    deltaT = 0.01;\n    thetadot = thetadot + deltaT * thetadotdot;\n    theta = theta + deltaT * thetadot;\n\n    Mass_Matrix =[I1 + I2 + L1^2*m1 + L1^2*m2 + L2^2*m2 + 2*L1*L2*m2*cos(theta(2)), m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2; m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2, m2*L2^2 + I2];\n    \n    Coriolis_Matrix = [-L1*L2*m2*thetadot(2)*sin(theta(2)),  -L1*L2*m2*sin(theta(2))*(thetadot(1) + thetadot(2));L1*L2*m2*thetadot(1)*sin(theta(2)), 0] ;\n    \n    gravity_vector = [(g*(m1+m2)*L1*cos(theta(1))) + g*m2*L2*cos(theta(1) + theta(2)); g*m2*L2*cos(theta(1) + theta(2))];\n    \n    B = eye(2); % Case 2\n\n    thetadotdot = (inv(Mass_Matrix)) * (tau - Coriolis_Matrix * thetadot -B*thetadot - gravity_vector);\n\nend\n\nclose(v);\nclose all\n\n```\n</details>\n\n#### Result:\n\n<img src=\"Pendulum_Case_2.gif\" alt=\"Animated GIF\" loop width=\"50%\" height=\"100%\">\n\n\n* **Environment 3:** Make a simulation where $\\normalsize \\tau = [20, 5]^ùëá$ and the robot has viscous friction $\\normalsize ùêµ = ùêº$.\n\n\n### Implementations\n\n#### Python\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom matplotlib.animation import PillowWriter\nfrom scipy.spatial.transform import Rotation as R\n\ndef expm(A):\n    return np.linalg.matrix_power(np.eye(A.shape[0]) + A / 16, 16)\n\ndef bracket_s(s):\n    return np.array([[0, -s[2], s[1], s[3]], [s[2], 0, -s[0], s[4]], [-s[1], s[0], 0, s[5]], [0, 0, 0, 0]])\n\ndef fk(M, S, theta):\n    T = np.eye(4)\n    for i in range(len(theta)):\n        T = np.dot(T, expm(bracket_s(S[:, i]) * theta[i]))\n    return np.dot(T, M)\n\n# System parameters\nL1 = 1\nL2 = 1\nm1 = 1\nm2 = 1\nI1 = 0.1\nI2 = 0.1\ng = 9.81\ntau = np.array([20, 5])  # Case 3\n\n# Initial conditions\ntheta = np.array([0.0, 0.0])\nthetadot = np.array([0.0, 0.0])\nthetadotdot = np.array([0.0, 0.0])\n\nomega = np.array([0, 0, 1])\nq1 = np.array([0, 0, 0])\nq2 = np.array([L1, 0, 0])\nq3 = np.array([L1 + L2, 0, 0])\n\nS1 = np.hstack((omega, -np.cross(omega, q1)))\nS2 = np.hstack((omega, -np.cross(omega, q2)))\nS_eq1 = np.column_stack((S1, np.zeros(6)))\nS_eq2 = np.column_stack((S1, S2))\n\nM1 = np.vstack((np.hstack((np.eye(3), q2[:, None])), [0, 0, 0, 1]))\nM2 = np.vstack((np.hstack((np.eye(3), np.array([[L1 + L2, 0, 0]]).T)), [0, 0, 0, 1]))\n\n# Plot setup\nmax_reach = L1 + L2\nfig, ax = plt.subplots()\nax.set_xlim(-3, 3)\nax.set_ylim(-3, 3)\nax.grid()\n\n# Animation setup\nframes = 1000\ndeltaT = 0.01\nlines, = ax.plot([], [], 'o-', color=[1, 0.5, 0], linewidth=4)\n\n\ndef animate(idx):\n    global theta, thetadot, thetadotdot\n    p0 = np.array([0,0])\n    T1 = fk(M1, S_eq2[:, 0:1], theta[0:1])\n    p1 = T1[0:2, 3]\n    T2 = fk(M2, S_eq2, theta)\n    p2 = T2[0:2, 3]\n    P = np.column_stack((p0, p1, p2))\n\n    lines.set_data(P[0, :], P[1, :])\n\n    thetadot += deltaT * thetadotdot\n    theta += deltaT * thetadot\n\n    # Dynamics and integration\n    Mass_Matrix = np.array([\n        [I1 + I2 + L1**2*m1 + L1**2*m2 + L2**2*m2 + 2*L1*L2*m2*np.cos(theta[1]), m2*L2**2 + L1*m2*np.cos(theta[1])*L2 + I2],\n        [m2*L2**2 + L1*m2*np.cos(theta[1])*L2 + I2, m2*L2**2 + I2]\n    ])\n\n    Coriolis_Matrix = np.array([\n        [-L1*L2*m2*thetadot[1]*np.sin(theta[1]), -L1*L2*m2*np.sin(theta[1])*(thetadot[0] + thetadot[1])],\n        [L1*L2*m2*thetadot[0]*np.sin(theta[1]), 0]\n    ])\n\n    gravity_vector = np.array([\n        g*(m1 + m2)*L1*np.cos(theta[0]) + g*m2*L2*np.cos(np.sum(theta)),\n        g*m2*L2*np.cos(np.sum(theta))\n    ])\n\n    B = np.array([[1, 0], [0, 1]])  # Case 3\n\n    thetadotdot = np.linalg.inv(Mass_Matrix) @ (tau - Coriolis_Matrix @ thetadot - B @ thetadot - gravity_vector)\n \n\n    return lines,\n\nani = animation.FuncAnimation(fig, animate, frames=frames, interval=deltaT*1000, blit=False)\n\n# Save as GIF\nani.save('Pendulum_Python_3.gif', writer=PillowWriter(fps=33))\n```\n:::\n\n\n#### MATLAB\n\n<details>\n<summary>Code</summary>\n\n```matlab\n\nclose all\nclear\nclc\n\n\n% create figure\nfigure\naxis([-2, 2, -2, 2])\ngrid on\nhold on\n\n% save as a video file\nv = VideoWriter('Pendulum_Python_3.mp4', 'MPEG-4');\nv.FrameRate = 100;\nopen(v);\n\n% pick your system parameters\nL1 = 1;\nL2 = 1;\nm1 = 1;\nm2 = 1;\nI1 = 0.1;\nI2 = 0.1;\ng = 9.81;\ntau = [20;5]; % Case 3\n\n% Initial conditions\ntheta = [0;0]; % joint position\nthetadot = [0;0]; % joint velocity\nthetadotdot = [0;0]; % joint acceleration\n\nmasses = [m1,m2];\nomega = [0;0;1];\n\nInertia_1 = [0 0 0;0 0 0;0 0 I1];\nInertia_2 = [0 0 0;0 0 0;0 0 I2];\nq1 = [0;0;0]; % Position of Joint 1\nq2 = [L1;0;0]; % Position of Joint 2\nq3 = [L1+L2;0;0]; % end effector position\n\nS1 = [omega; -cross(omega,q1)];\nS2 = [omega;-cross(omega,q2)];\nS_eq1 = [S1,[0;0;0;0;0;0]];\nS_eq2 = [S1, S2]; \n\nM1 = [eye(3),q2; 0 0 0 1];\nM2 = [eye(3), [L1+L2;0;0]; 0 0 0 1];\n\ngravity_vector = (zeros(length(theta),1));\nCoriolis_Matrix = (zeros(2,2));\nMass_Matrix = [I1 + I2 + L1^2*m1 + L1^2*m2 + L2^2*m2 + 2*L1*L2*m2*cos(theta(2)), m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2; m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2, m2*L2^2 + I2];\n    \n\nfor idx = 1:1000\n\n    % plot the robot\n    % 1. get the position of each link\n    p0 = [0; 0];\n    T1 = fk(M1,S_eq2(:,1:1),theta(1:1,:));\n    p1 = T1(1:2,4); % position of link 1 (location of joint 2)\n    T2 = fk(M2,S_eq2,theta);\n    p2 = T2(1:2,4); % position of link 2 (the end-effector)\n    P = [p0, p1, p2];\n    % 2. draw the robot and save the frame\n    cla;\n    plot(P(1,:), P(2,:), 'o-', 'color',[1, 0.5, 0],'linewidth',4);\n    drawnow;\n    frame = getframe(gcf);\n    writeVideo(v,frame);\n\n    % integrate to update velocity and position\n    % your code here\n    deltaT = 0.01;\n    thetadot = thetadot + deltaT * thetadotdot;\n    theta = theta + deltaT * thetadot;\n\n    Mass_Matrix =[I1 + I2 + L1^2*m1 + L1^2*m2 + L2^2*m2 + 2*L1*L2*m2*cos(theta(2)), m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2; m2*L2^2 + L1*m2*cos(theta(2))*L2 + I2, m2*L2^2 + I2];\n    \n    Coriolis_Matrix = [-L1*L2*m2*thetadot(2)*sin(theta(2)),  -L1*L2*m2*sin(theta(2))*(thetadot(1) + thetadot(2));L1*L2*m2*thetadot(1)*sin(theta(2)), 0] ;\n    \n    gravity_vector = [(g*(m1+m2)*L1*cos(theta(1))) + g*m2*L2*cos(theta(1) + theta(2)); g*m2*L2*cos(theta(1) + theta(2))];\n    \n    B = eye(2); % Case 3\n\n    thetadotdot = (inv(Mass_Matrix)) * (tau - Coriolis_Matrix * thetadot -B*thetadot - gravity_vector);\n\nend\n\nclose(v);\nclose all\n```\n</details>\n\n#### Result:\n\n<img src=\"Pendulum_Case_3.gif\" alt=\"Animated GIF\" loop width=\"50%\" height=\"100%\">\n\n\n\n```{=html}\n<script>\nconst tooltipTriggerList = document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')\nconst tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))\n</script>\n<style>\ndiv#quarto-sidebar-glass { display: none !important; }\nul.navbar-nav.navbar-nav-scroll { -webkit-flex-direction: row !important; }\n/* #quarto-sidebar { padding: 5px; }\n#quarto-sidebar > * { padding: 5px; }\ndiv.sidebar-menu-container > * { padding: 5px 5px 5px 5px; }\n#quarto-margin-sidebar { padding: 40px; } */\n</style>\n```\n\n",
    "supporting": [
      "Dynamics_files"
    ],
    "filters": [],
    "includes": {}
  }
}