{
  "hash": "bd11d2bb37c761bc99fa5e920f4d562b",
  "result": {
    "markdown": "---\ntitle: \"Motion Planning & Trajectory Optimization\"\ndescription: \"Motion Planning in robotics focuses on devising efficient paths for a robot from its current state to a goal, while Trajectory Optimization refines these paths for smooth and obstacle-free motion, crucial for precise robotic movements in various applications\"\ndate: 12-19-2023\ncategories: [Robotics]\nimage: Trajectory_Cover_GIF.gif\nformat:\n    html: \n        code-fold: show\n        code-overflow: wrap\n        code-tools: true\n\n---\n\n# Motion Planning\n\n## Potential Fields\n\nHere I will use potential fields to get a motion plan for the 2-DoF environment shown below. Here the drone’s position is $\\normalsize \\theta = [𝑥, 𝑦]^𝑇$.\n\nImplementing the potential fields approach:\n\n• Setting $\\normalsize \\theta_{𝑠𝑡𝑎𝑟𝑡} = [0, 0]^𝑇 \\; and \\; \\theta_{𝑔𝑜𝑎l} = [1, 1]^𝑇$\n\n• The first obstacle has $\\normalsize center \\; 𝑐_1 = [0.3, 0.5]^𝑇 \\; and \\; radius \\; 𝑟_1 = 0.125$.\n\n• The second obstacle has center $\\normalsize center \\; 𝑐_2 = [0.7, 0.5]^𝑇 \\; and \\; radius \\; 𝑟_2 = 0.225$.\n\nNOTE: Always start with a low learning rate $\\normalsize \\alpha$ in your g\n\n### Implementations\n\n#### Python\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation, PillowWriter\n\n# Parameters\ntheta_start = np.array([0.0, 0.0])\ntheta_goal = np.array([1.0, 1.0])\ncenters = np.array([[0.3, 0.5], [0.7, 0.5]])\nradii = np.array([0.125, 0.225])\n\n# Function to compute potential field\ndef field(theta, theta_goal, centers, radii):\n    U = 0.5 * np.linalg.norm(theta_goal - theta)**2\n    for idx in range(len(radii)):\n        center = centers[idx]\n        radius = radii[idx]\n        dist = np.linalg.norm(center - theta)\n        if dist < radius:\n            U += 0.5 * (1/dist - 1/radius)**2\n    return U\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\n\n# Drawing circles\nfor idx in range(len(radii)):\n    circle = plt.Circle(centers[idx], radii[idx], color=[0.5, 0.5, 0.5], fill=False)\n    ax.add_patch(circle)\n\n# Start and goal points\nax.plot(theta_start[0], theta_start[1], 'ko', markerfacecolor='k')\nax.plot(theta_goal[0], theta_goal[1], 'ko', markerfacecolor='k')\nax.axis('equal')\n\n# Parameters for gradient descent\ntheta = theta_start\ndelta = 0.01  # Adjusted delta value\nlearning_rate = 0.01  # Adjusted learning rate\npath = [theta_start]  # To store the path\n\n# Animation update function\ndef update(frame):\n    global theta\n    if np.linalg.norm(theta - theta_goal) < 0.1:\n        return\n\n    U = field(theta, theta_goal, centers, radii)\n    U1 = field(theta + np.array([delta, 0.0]), theta_goal, centers, radii)\n    U2 = field(theta + np.array([0.0, delta]), theta_goal, centers, radii)\n    Ugrad = np.array([U1 - U, U2 - U]) / delta\n    theta -= learning_rate * Ugrad\n    path.append(theta.copy())\n    ax.plot([p[0] for p in path], [p[1] for p in path], 'o', color=[1, 0.5, 0], markerfacecolor=[1, 0.5, 0])\n\n# Create animation\nani = FuncAnimation(fig, update, frames=np.arange(300), repeat=False)\n\n# Save to GIF using PillowWriter\ngif_path = 'Potential_Field.gif'\nani.save(gif_path, writer=PillowWriter(fps=30))\n```\n:::\n\n\n**MATLAB**\n\n<details>\n\n```matlab\n\nclear\nclose all\n% Parameters\ntheta_start = [0; 0];\ntheta_goal = [1; 1];\ncenters = [.3, .7; .5, .5];\nradii = [.125, .225];\n% Create figure\nfigure\ngrid on\nhold on\nfor idx = 1:length(radii)\n viscircles(centers(:,idx)', radii(idx), 'Color', [0.5, 0.5, 0.5]);\nend\nplot(theta_start(1), theta_start(2), 'ko', 'MarkerFaceColor', 'k')\nplot(theta_goal(1), theta_goal(2), 'ko', 'MarkerFaceColor', 'k')\naxis equal\n% Gradient descent down potential field\ntheta = theta_start;\ndelta = 0.01;\nlearning_rate = 0.01;\nfor idx = 1:1000\n if norm(theta - theta_goal) < 0.1\n break\n end\n U = field(theta, theta_goal, centers, radii);\n U1 = field(theta + [delta; 0], theta_goal, centers, radii);\n U2 = field(theta + [0; delta], theta_goal, centers, radii);\n Ugrad = [U1 - U; U2 - U] / delta;\n theta = theta - learning_rate * Ugrad;\n plot(theta(1), theta(2), 'o', 'color', [1, 0.5, 0], ...\n 'MarkerFaceColor', [1, 0.5, 0])\nend\n% Find potential field at position theta\nfunction U = field(theta, theta_goal, centers, radii)\n U = 0.5 * norm(theta_goal - theta)^2;\n for idx = 1:length(radii)\n center = centers(:, idx);\n radius = radii(idx);\n dist = norm(center - theta);\n if dist < radius\n U = U + 0.5 * (1/dist - 1/radius)^2;\n end\n end\nend\n```\n</details>\n\n#### Result:\n\n<img src=\"Potential_Field.gif\" alt=\"Animated GIF\" loop width=\"50%\" height=\"50%\">\n\n\n\n* Modifying the position of the obstacles so that a valid plan from 𝜃𝑠𝑡𝑎𝑟𝑡 to 𝜃𝑔𝑜𝑎𝑙 exists but the potential fields planner fails (i.e., gets stuck). Below is a simulation that shows the obstacles and the failed motion plan.\n\nThere are many possible solutions. For instance, I am setting $\\normalsize 𝑐_1 = [0.4, 0.5]^𝑇$.\n\n## Motion Plan Failure\n\n### Implementations\n\n#### Python\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation, PillowWriter\n\n# Parameters\ntheta_start = np.array([0.0, 0.0])\ntheta_goal = np.array([1.0, 1.0])\ncenters = np.array([[0.4, 0.5], [0.5, 0.5]])\nradii = np.array([0.125, 0.225])\n\n# Function to compute potential field\ndef field(theta, theta_goal, centers, radii):\n    U = 0.5 * np.linalg.norm(theta_goal - theta)**2\n    for idx in range(len(radii)):\n        center = centers[idx]\n        radius = radii[idx]\n        dist = np.linalg.norm(center - theta)\n        if dist < radius:\n            U += 0.5 * (1/dist - 1/radius)**2\n    return U\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\n\n# Drawing circles\nfor idx in range(len(radii)):\n    circle = plt.Circle(centers[idx], radii[idx], color=[0.5, 0.5, 0.5], fill=False)\n    ax.add_patch(circle)\n\n# Start and goal points\nax.plot(theta_start[0], theta_start[1], 'ko', markerfacecolor='k')\nax.plot(theta_goal[0], theta_goal[1], 'ko', markerfacecolor='k')\nax.axis('equal')\n\n# Parameters for gradient descent\ntheta = theta_start\ndelta = 0.01  # Adjusted delta value\nlearning_rate = 0.01  # Adjusted learning rate\npath = [theta_start]  # To store the path\n\n# Animation update function\ndef update(frame):\n    global theta\n    if np.linalg.norm(theta - theta_goal) < 0.1:\n        return\n\n    U = field(theta, theta_goal, centers, radii)\n    U1 = field(theta + np.array([delta, 0.0]), theta_goal, centers, radii)\n    U2 = field(theta + np.array([0.0, delta]), theta_goal, centers, radii)\n    Ugrad = np.array([U1 - U, U2 - U]) / delta\n    theta -= learning_rate * Ugrad\n    path.append(theta.copy())\n    ax.plot([p[0] for p in path], [p[1] for p in path], 'o', color=[1, 0.5, 0], markerfacecolor=[1, 0.5, 0])\n\n# Create animation\nani = FuncAnimation(fig, update, frames=np.arange(300), repeat=False)\n\n# Save to GIF using PillowWriter\ngif_path = 'Potential_Field_fail.gif'\nani.save(gif_path, writer=PillowWriter(fps=30))\n```\n:::\n\n\n**MATLAB**\n\n<details>\n\n```matlab\nclear\nclose all\n\n% Start and goal environments\ntheta_start= [0; 0];\ntheta_goal = [1; 1];\n\n% Modified obstacle positions and sizes\nobs_c21 = [0.3; 0.5];  % Shifted first obstacle closer to the second\nobs_r21 = 0.15;        % Slightly increased radius\nobs_c22 = [0.8; 0.5];  % Shifted second obstacle closer to the first\nobs_r22 = 0.25;        % Slightly increased radius\n\n% Visualize the environment\nfigure\ngrid on\nhold on\naxis([0, 1, 0, 1])\naxis equal\nviscircles(obs_c21', obs_r21, 'Color', [0.5, 0.5, 0.5]);\nviscircles(obs_c22', obs_r22, 'Color', [0.5, 0.5, 0.5]);\nplot(0, 0, 'ko', 'MarkerFaceColor', 'k');\nplot(1, 1, 'ko', 'MarkerFaceColor', 'k');\n\n% Setting the variables\nalpha= 0.01;\nepsilon = 0.1;\ndelta= 0.01;\n\n% Initial trajectory\ntheta(:,1) = theta_start;\nt=1;\ndel_Unet=1;\n\nwhile norm(del_Unet)> epsilon\n    del_Ux= U_theta(theta(:,t) + [delta;0]);\n    del_Uy= U_theta(theta(:,t)+ [0;delta]);\n    del_U= U_theta(theta(:,t));\n\n    del_Unet=[del_Ux-del_U; del_Uy-del_U]/delta;\n\n    theta(:,t+1)= theta(:,t)- alpha*del_Unet;\n    t=t+1;\nend\n\n\ngrid on\nhold on\naxis equal\nplot(theta(1,:), theta(2,:), 'o-',...\n    'Color', [1, 0.5, 0], 'LineWidth', 2);\n    \n\nfunction U = U_theta(theta) \n    beta=2;\n    gamma=1;\n    theta_goal = [1; 1];\n    % Modified obstacle positions and sizes\n    obs_c21 = [0.3; 0.5];  % Update obstacle parameters\n    obs_r21 = 0.15;\n    obs_c22 = [0.6; 0.5];\n    obs_r22 = 0.25;\n\n    Urep1=0;\n    Urep2=0;\n\n    Uatt=0.5*beta*norm(theta_goal-theta)^2;    \n\n    if norm(obs_c21-theta)<= obs_r21\n        Urep1=0.5* gamma*((1/norm(obs_c21-theta))- (1/obs_r21))^2;\n    end\n    if norm(obs_c22-theta)<= obs_r22\n        Urep2= 0.5*gamma*((1/norm(obs_c22-theta))- (1/obs_r22))^2;\n    end\n\n    Urep= Urep1+ Urep2;\n    disp(Urep);\n    U= Uatt + Urep;\nend\n```\n</details>\n\n#### Result:\n\n<img src=\"Potential_Field_fail.gif\" alt=\"Animated GIF\" loop width=\"50%\" height=\"50%\">\n\nThis failure occurs because the robot uses gradient descent to move towards decreasing potential energy, and the robot gets trapped in a **local minimum**.\n\nIn this modification, the obstacles are placed closer to each other, potentially creating a narrow corridor that the drone might not be able to navigate due to the combined repulsive forces. This setup can result in the planner getting stuck in a local minimum, where the drone is unable to progress towards the goal. Thus, we place a local minimim in between the start and goal. **Gradient descent** can only climb \"down\" so if it's surrounded by high gradients, it can't escape.\n\n\n\n\n## Trajectory Optimization\n\n**(MATLAB Implementations provided below)**\n\nHere we are using trajectory optimization to perform motion planning in 2-DoF environments. As before, the mobile robot’s position is $\\normalsize \\theta = [𝑥, 𝑦]^𝑇$.\n\nImplementing the trajectory optimization algorithm Below. My code should be able to work with an arbitrary number of waypoints and circular obstacles. \n\nThus setting the initial trajectory $\\normalsize \\xi^0$ as:\n\n$$\\normalsize \\xi^0 = \\left(\\begin{array}{cc} \nlinspace(\\theta_{start}(1), \\; \\theta_{goal}(1), \\; k)\\\\\nlinspace(\\theta_{start}(1), \\; \\theta_{goal}(1), \\; k)\n\\end{array}\\right)\n$$\n\n\n\n\n* **Environment 1: One obstacle with $\\normalsize center \\; 𝑐_1 = [0.2, 0.35]^𝑇 \\; and \\; radius \\; 𝑟_1 = 0.2$. A second obstacle with $\\normalsize center \\; 𝑐_2 = [0.5, 0.3]^𝑇 \\; and \\; radius \\; 𝑟_2 = 0.2$. A third obstacle with $\\normalsize center \\; 𝑐_3 = [0.7, 0.5]^𝑇 \\; and \\; radius \\; 𝑟_3 = 0.2$. Setting $\\normalsize 𝑘 = 20$.**\n\n<details open>\n<summary>MATLAB Code</summary>\n\n```matlab\nclear\nclose all\n\n% start and goal\ntheta_start = [0;0];\ntheta_goal = [1;1];\ncenters = [0.2 0.5, 0.7; 0.35 0.3, 0.5];\nradii = [0.2, 0.2, 0.2];\n\n% initial trajectory\nn = 2;\nk = 20;\nxi_0 = [linspace(theta_start(1), theta_goal(1), k);...\n linspace(theta_start(2), theta_goal(2), k)];\nxi_0_vec = reshape(xi_0, [], 1);\n\n% start and goal equality constraints\nA = [eye(n) zeros(n, n*(k-1));...\n zeros(n, n*(k-1)), eye(n)];\nB = [theta_start; theta_goal];\n\n% nonlinear optimization\noptions = optimoptions('fmincon','Display','final',...\n 'Algorithm','sqp','MaxFunctionEvaluations',1e5);\nxi_star_vec = fmincon(@(xi) cost(xi, centers, radii), xi_0_vec, ...\n [], [], A, B, [], [], [], options);\nxi_star = reshape(xi_star_vec, 2, []);\n\n% plot result\nfigure\ngrid on\nhold on\naxis equal\nfor idx = 1:length(radii)\n viscircles(centers(:, idx)', radii(idx), 'Color', [0.5, 0.5, ...\n 0.5]);\nend\nplot(xi_0(1,:), xi_0(2,:), 'o-', 'Color', [0.3, 0.3, ...\n 0.3], 'LineWidth', 3);\nplot(xi_star(1,:), xi_star(2,:), 'o-', 'Color', [1, 0.5, ...\n 0], 'LineWidth', 3);\n% cost function to minimize\n\nfunction C = cost(xi, centers, radii)\n xi = reshape(xi, 2, []);\n C = 0;\n for idx = 2:length(xi)\n theta_curr = xi(:, idx);\n theta_prev = xi(:, idx - 1);\n C = C + norm(theta_curr - theta_prev)^2;\n for jdx = 1:length(radii)\n center = centers(:, jdx);\n radius = radii(jdx);\n if norm(theta_curr - center) < radius\n C = C + 0.5*(1/norm(theta_curr - center) - 1/radius)^2;\n end\n end\n end\nend\n```\n</details>\n\n#### Result:\n\n![](Images/Traj_Env_1.png){fig-align=\"center\" width=50%}\n\n\n* **Environment 2: One obstacle with $\\normalsize center \\; 𝑐_1 = [0.5, 0.3]^𝑇 \\; and \\; radius \\; 𝑟_1 = 0.3$. A second obstacle with $\\normalsize center \\; 𝑐_2 = [0.5, 0.7]^𝑇 \\; and \\; radius \\; 𝑟_2 = 0.2$. Setting $\\normalsize 𝑘 = 15$ waypoints.**\n\n<details open>\n<summary>MATLAB Code</summary>\n\n```matlab\nclear\nclose all\n\n% start and goal\ntheta_start = [0;0];\ntheta_goal = [1;1];\ncenters = [0.5 0.5; 0.3 0.7];\nradii = [0.3, 0.2];\n\n% initial trajectory\nn = 2;\nk = 15;\nxi_0 = [linspace(theta_start(1), theta_goal(1), k);...\n linspace(theta_start(2), theta_goal(2), k)];\nxi_0_vec = reshape(xi_0, [], 1);\n\n% start and goal equality constraints\nA = [eye(n) zeros(n, n*(k-1));...\n zeros(n, n*(k-1)), eye(n)];\nB = [theta_start; theta_goal];\n\n% nonlinear optimization\noptions = optimoptions('fmincon','Display','final',...\n 'Algorithm','sqp','MaxFunctionEvaluations',1e5);\nxi_star_vec = fmincon(@(xi) cost(xi, centers, radii), xi_0_vec, ...\n [], [], A, B, [], [], [], options);\nxi_star = reshape(xi_star_vec, 2, []);\n\n% plot result\nfigure\ngrid on\nhold on\naxis equal\nfor idx = 1:length(radii)\n viscircles(centers(:, idx)', radii(idx), 'Color', [0.5, 0.5, ...\n 0.5]);\nend\nplot(xi_0(1,:), xi_0(2,:), 'o-', 'Color', [0.3, 0.3, ...\n 0.3], 'LineWidth', 3);\nplot(xi_star(1,:), xi_star(2,:), 'o-', 'Color', [1, 0.5, ...\n 0], 'LineWidth', 3);\n\n% cost function to minimize\nfunction C = cost(xi, centers, radii)\n xi = reshape(xi, 2, []);\n C = 0;\n for idx = 2:length(xi)\n theta_curr = xi(:, idx);\n theta_prev = xi(:, idx - 1);\n C = C + norm(theta_curr - theta_prev)^2;\n for jdx = 1:length(radii)\n center = centers(:, jdx);\n radius = radii(jdx);\n if norm(theta_curr - center) < radius\n C = C + 0.5*(1/norm(theta_curr - center) - 1/radius)^2;\n end\n end\n end\nend\n```\n</details>\n\n#### Result:\n\n![](Images/Traj_Env_2.png){fig-align=\"center\" width=50%}\n\n\n* **Environment 3: One obstacle with $\\normalsize center \\; 𝑐_1 = [0.55, 0.5]^𝑇 \\; and \\; radius \\; 𝑟_1 = 0.3$. Trajectory should have $\\normalsize 𝑘 = 10$ waypoints.**\n\n<details open>\n<summary>MATLAB Code</summary>\n\n```matlab\nclear\nclose all\n\n% start and goal\ntheta_start = [0;0];\ntheta_goal = [1;1];\ncenters = [0.55; 0.5];\nradii = 0.3;\n\n% initial trajectory\nn = 2;\nk = 10;\nxi_0 = [linspace(theta_start(1), theta_goal(1), k);...\n linspace(theta_start(2), theta_goal(2), k)];\nxi_0_vec = reshape(xi_0, [], 1);\n\n% start and goal equality constraints\nA = [eye(n) zeros(n, n*(k-1));...\n zeros(n, n*(k-1)), eye(n)];\nB = [theta_start; theta_goal];\n\n% nonlinear optimization\noptions = optimoptions('fmincon','Display','final',...\n 'Algorithm','sqp','MaxFunctionEvaluations',1e5);\nxi_star_vec = fmincon(@(xi) cost(xi, centers, radii), xi_0_vec, ...\n [], [], A, B, [], [], [], options);\nxi_star = reshape(xi_star_vec, 2, []);\n\n% plot result\nfigure\ngrid on\nhold on\naxis equal\nfor idx = 1:length(radii)\n viscircles(centers(:, idx)', radii(idx), 'Color', [0.5, 0.5, ...\n 0.5]);\nend\nplot(xi_0(1,:), xi_0(2,:), 'o-', 'Color', [0.3, 0.3, ...\n 0.3], 'LineWidth', 3);\nplot(xi_star(1,:), xi_star(2,:), 'o-', 'Color', [1, 0.5, ...\n 0], 'LineWidth', 3);\n\n% cost function to minimize\nfunction C = cost(xi, centers, radii)\n xi = reshape(xi, 2, []);\n C = 0;\n for idx = 2:length(xi)\n theta_curr = xi(:, idx);\n theta_prev = xi(:, idx - 1);\n C = C + norm(theta_curr - theta_prev)^2;\n for jdx = 1:length(radii)\n center = centers(:, jdx);\n radius = radii(jdx);\n if norm(theta_curr - center) < radius\n C = C + 0.5*(1/norm(theta_curr - center) - 1/radius)^2;\n end\n end\n end\nend\n```\n</details>\n\n#### Result:\n\n![](Images/Traj_Env_3.png){fig-align=\"center\" width=50%}\n\n*Legend: Here, in all the three environments the gray line is the initial trajectory $\\normalsize \\xi^0$, while the orange line is the optimal trajectory $\\normalsize \\xi$.*\n\n# Special Scenario\n\n**Consider an environment with two obstacles:**\n\n* $\\normalsize \\theta_{start} = [0, 0]^𝑇 \\; and \\; \\theta_{goal} = [1, 1]^𝑇$.\n\n* First obstacle with $\\normalsize center \\; 𝑐_1 = [0.4, 0.6]^𝑇 \\; and \\; radius \\; 𝑟_1 = 0.2$.\n\n* Second obstacle with $\\normalsize center \\; 𝑐_2 = [0.6, 0.4]^𝑇 \\; and \\; radius \\; 𝑟_2 = 0.2$.\n\n* The trajectory $\\normalsize \\xi$ should have $\\normalsize k = 20$ waypoints.\n\nModifying the initial trajectory $\\normalsize \\xi^0$ so that the optimal trajectory goes around both obstacles.\n\n**Solution:**\n\nFor this environment an **initial trajectory $\\normalsize \\xi^0$** that moves straight from start to goal gets stuck. The nonlinear optimizer cannot find a way to modify this initial trajectory to **decrease the cost** (i.e., we are stuck in a local minima), and so the final answer simply jumps across the obstacles. We can fix this problem by choosing an initial trajectory that moves either above or below the obstacles. \n\nFor example, we can try:\n\n$$\\normalsize \\xi^0 = \\left(\\begin{array}{cc} \n0 && 0 && 0 && . && . && . && 0\\\\\n0 && 1/(k-1) && 2/(k-1) && . && . && . && 1\n\\end{array}\\right)\n$$\n\nWhere $\\normalsize \\xi^0 ∈ R^{𝑛×𝑘}$\n\nThis results in an optimal trajectory $\\normalsize \\xi$ that goes above both obstacles. See the figure below. If we select an initial trajectory that causes the robot to converge to a path below both obstacles, that is also fine.\n\n#### Result:\n\n![](Images/Traj_Env_4_special.png){fig-align=\"center\" width=50%}\n\n\n\n\n\n```{=html}\n<script>\nconst tooltipTriggerList = document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')\nconst tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))\n</script>\n<style>\ndiv#quarto-sidebar-glass { display: none !important; }\nul.navbar-nav.navbar-nav-scroll { -webkit-flex-direction: row !important; }\n/* #quarto-sidebar { padding: 5px; }\n#quarto-sidebar > * { padding: 5px; }\ndiv.sidebar-menu-container > * { padding: 5px 5px 5px 5px; }\n#quarto-margin-sidebar { padding: 40px; } */\n</style>\n```\n\n",
    "supporting": [
      "Potential_trajectory_files"
    ],
    "filters": [],
    "includes": {}
  }
}